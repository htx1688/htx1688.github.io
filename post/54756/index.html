<!DOCTYPE html>
<html
  lang="zh-cn"
  itemscope
  itemtype="http://schema.org/WebPage"
>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>
          一文读懂微软开发的Nova系统：如何成为零知识证明的新篇章？ - 区块大全
        </title>
    

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="佚名" /><meta name="description" content="Nova是微软开发的一种新型零知识证明系统，它使用了一种名为松弛的秩一约束系统（Relaxed Rank-1 Constraint Systems，Relaxed R1CS）的技术，以提高证明的效率和灵活性。" />
<meta name="keywords" content="微軟" />







<meta name="generator" content="Hugo 0.120.4" />


<link rel="canonical" href="/post/54756/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.d8d87b982993a745e5e7b6a6cbf257be8c3e82aab5e485f0908ad7e6c3501ab2.css" integrity="sha256-2Nh7mCmTp0Xl57amy/JXvow&#43;gqq15IXwkIrX5sNQGrI=" media="screen" crossorigin="anonymous">







<meta property="og:title" content="一文读懂微软开发的Nova系统：如何成为零知识证明的新篇章？" />
<meta property="og:description" content="Nova是微软开发的一种新型零知识证明系统，它使用了一种名为松弛的秩一约束系统（Relaxed Rank-1 Constraint Systems，Relaxed R1CS）的技术，以提高证明的效率和灵活性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/54756/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-07-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-07-11T00:00:00+00:00" />

<meta itemprop="name" content="一文读懂微软开发的Nova系统：如何成为零知识证明的新篇章？">
<meta itemprop="description" content="Nova是微软开发的一种新型零知识证明系统，它使用了一种名为松弛的秩一约束系统（Relaxed Rank-1 Constraint Systems，Relaxed R1CS）的技术，以提高证明的效率和灵活性。"><meta itemprop="datePublished" content="2023-07-11T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-07-11T00:00:00+00:00" />
<meta itemprop="wordCount" content="17942">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="一文读懂微软开发的Nova系统：如何成为零知识证明的新篇章？"/>
<meta name="twitter:description" content="Nova是微软开发的一种新型零知识证明系统，它使用了一种名为松弛的秩一约束系统（Relaxed Rank-1 Constraint Systems，Relaxed R1CS）的技术，以提高证明的效率和灵活性。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




  </head>
  <body>
    <div id="back-to-top"></div>

    <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">区块大全</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="/categories/">分类</a>
          
        
      </li>
    

    
  </ul>
</nav>


    
      






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

    

    

    


    <header id="header" class="header">
      <div class="logo-wrapper">
  <a href="/" class="logo">
    
      区块大全
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/categories/">分类</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

    </header>

    <div id="mobile-panel">
      <main id="main" class="main bg-llight wallpaper">
        <div class="content-wrapper">
    <div id="content" class="content">
      <article class="post">
        
        <header class="post-header">
          <h1 class="post-title">一文读懂微软开发的Nova系统：如何成为零知识证明的新篇章？</h1>
          

          <div class="post-meta">
  <div class="post-meta-author">
    by
      佚名
    
  </div>

  <div class="post-meta-time">
    <time datetime="2023-07-11">
      2023-07-11
    </time>
  </div>

  


  <div class="post-meta__right">
    <span class="post-meta-more">
        约 17942 字 -
        预计阅读 36 分钟
      </span>

    <div class="post-meta-category">
        <a href="/categories/%E5%85%B6%E5%AE%83%E6%96%87%E7%AB%A0/"> 其它文章 </a>
          
      </div>


    
    


    
    
  </div>
</div>

        </header>

        
        <div class="post-content">
          <table>
    <thead>
        <tr>
            <th style="text-align:left">推荐平台</th>
            <th style="text-align:left">链接</th>
            <th style="text-align:left">平台介绍</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="text-align:left"><span style="white-space:nowrap">币安网</span></td>
            <td style="text-align:left"><span style="white-space:nowrap"><a
                        href="https://www.okbtc.cn/binance?ref=githubio">注册链接</a></span></td>
            <td style="text-align:left"><a
                    href="https://www.okbtc.cn/binance?ref=githubio">币安是全球领先的区块链生态系统，推出了一系列产品，其中包括最大的加密货币交易平台。我们的使命是在未来成为全球性加密货币基础架构供应商。</a>
            </td>
        </tr>
        <tr>
            <td style="text-align:left"><span style="white-space:nowrap">欧易OKX</span></td>
            <td style="text-align:left"><a href="https://www.okbtc.cn/okx?ref=githubio">注册链接</a></td>
            <td style="text-align:left"><a
                    href="https://www.okbtc.cn/okx?ref=githubio">欧易是全球著名的数字资产交易平台之一，主要面向全球用户提供比特币、莱特币、以太币等数字资产的币币和衍生品交易服务。</a>
            </td>
        </tr>
        <tr>
            <td style="text-align:left"><span style="white-space:nowrap">HTX火币</span></td>
            <td style="text-align:left"><a href="https://www.okbtc.cn/htx?ref=githubio">注册链接</a></td>
            <td style="text-align:left"><a
                    href="https://www.okbtc.cn/htx?ref=githubio">火币全球专业站，是火币集团旗下服务于全球专业交易用户的创新数字资产国际站，致力于发现优质的创新数字资产投资机会。</a>
            </td>
        </tr>
    </tbody>
</table>
<p>作者：Huobi Ventures 资深研究员谢锦斌</p>
<h3 id="引言">引言</h3>
<p>零知识证明是密码学中的一种重要技术，它允许一个人向另一个人证明一个陈述是真实的，而无需透露任何其他信息。这种技术在许多领域都有广泛的应用，包括身份验证、区块链和安全计算等。Nova是微软开发的一种新型零知识证明系统，它使用了一种名为松弛的秩一约束系统（Relaxed Rank-1 Constraint Systems，Relaxed R1CS）的技术，以提高证明的效率和灵活性。<strong>最后一章节对源码进行详细解读。</strong></p>
<h3 id="nova的优点">Nova的优点</h3>
<p>Nova的主要优点在于其使用的松弛的R1CS技术。R1CS是一种用于构建零知识证明的系统，它可以用于证明一个人知道满足一组多项式等式的解，而不必透露任何关于解的信息。然而，传统的R1CS系统需要在证明过程中使用大量的随机性，这会导致证明的生成和验证过程非常复杂和耗时。Nova通过使用松弛的R1CS来解决这个问题，它允许在证明中使用更少的随机性，从而大大提高了证明的效率。</p>
<p>Nova还具有其他一些优点。例如，它支持增量计算，这意味着可以逐步计算复杂的函数，而不必一次性计算整个函数。这在处理大规模数据或进行复杂计算时非常有用。此外，Nova还支持多项式计算，这使得它可以处理更复杂的证明任务。</p>
<h3 id="nova的缺点">Nova的缺点</h3>
<p>尽管Nova具有许多优点，但它也有一些缺点。首先，由于Nova使用的是松弛的R1CS，因此它的证明可能不如传统的R1CS系统那么强大。这是因为松弛的R1CS允许在证明中使用更少的随机性，这可能会降低证明的安全性。然而，Nova的开发者已经采取了一些措施来解决这个问题，例如使用更强大的密码学算法和更复杂的证明策略。</p>
<p>其次，Nova的实现相对复杂，这可能会增加使用和维护的难度。Nova使用了许多高级的密码学技术，如多项式计算、群操作和随机预言机等，这需要深入理解这些技术才能有效地使用和修改Nova。</p>
<h3 id="nova在零知识证明领域的重要地位">Nova在零知识证明领域的重要地位</h3>
<p>Nova在零知识证明领域中占据了重要的地位。它的出现，为零知识证明的发展开辟了新的道路。Nova采用的松弛的R1CS技术，使得证明的生成和验证过程更加高效，这对于大规模的零知识证明应用至关重要。此外，Nova还支持增量计算和多项式计算，这使得它可以处理更复杂的证明任务，进一步扩大了零知识证明的应用范围。</p>
<h3 id="nova的源码解读">Nova的源码解读</h3>
<p><a href="https://github.com/microsoft/Nova">https://github.com/microsoft/Nova</a></p>
<p>在 src/ 目录下，有以下几个重要的子目录：</p>
<p>bellperson/：这个目录可能包含了关于 Bellman-Ford 算法的代码。</p>
<p>gadgets/：这个目录可能包含了一些用于构建 zk-SNARK 证明的工具。</p>
<p>provider/：这个目录可能包含了一些提供者的代码，如 keccak.rs 可能是实现 Keccak 哈希函数的代码。</p>
<p>spartan/：这个目录可能包含了关于 Spartan 协议的代码。</p>
<p>traits/：这个目录可能包含了一些 Rust traits，用于定义一些公共的行为。</p>
<ul>
<li>
<p>src/bellperson/mod.rs 文件的内容：</p>
<p>这个模块主要用于生成 R1CS（Rank-1 Constraint Systems，一种用于 zk-SNARKs 的约束系统）。</p>
<p>它包含了三个子模块：</p>
<p>r1cs: 这个模块可能包含了关于 R1CS 的代码。</p>
<p>shape_cs: 这个模块可能包含了关于形状约束系统的代码。</p>
<p>solver: 这个模块可能包含了关于解决约束系统的代码。</p>
<p>在测试部分，它定义了一个函数 synthesize_alloc_bit，这个函数接受一个约束系统，然后添加一些约束来检查输入的两个比特是否确实是比特。然后，它定义了一个函数 test_alloc_bit_with，这个函数首先创建一个形状</p>
</li>
<li>
<p>src/bellperson/r1cs.rs 文件的内容：</p>
<p>这个文件主要定义了两个 trait：`NovaWitness` 和 `NovaShape`，它们分别提供了从实现者获取 `R1CSInstance` 和 `R1CSWitness`，以及获取 `R1CSShape` 和 `CommitmentKey` 的方法。</p>
<p>- `NovaWitness` trait 有一个方法 `r1cs_instance_and_witness`，它接受一个 `R1CSShape` 和一个 `CommitmentKey`，然后返回一个 `R1CSInstance` 和一个 `R1CSWitness`。这个 trait 为 `SatisfyingAssignment` 结构体实现，这意味着任何 `SatisfyingAssignment` 都可以使用这个方法来获取一个 `R1CSInstance` 和一个 `R1CSWitness`。</p>
<p>- `NovaShape` trait 有一个方法 `r1cs_shape`，它返回一个 `R1CSShape` 和一个 `CommitmentKey`。这个 trait 为 `ShapeCS` 结构体实现，这意味着任何 `ShapeCS` 都可以使用这个方法来获取一个 `R1CSShape` 和一个 `CommitmentKey`。</p>
<p>这个文件还定义了一个函数 `add_constraint`，它接受一个约束系统和三个线性组合，然后在约束系统中添加一个新的约束。这个函数被 `NovaShape` 的实现者在生成 `R1CSShape` 时使用。</p>
<p>总的来说，这个文件的主要作用是提供了一种方式，使得可以从一个满足特定条件的系统（如 `SatisfyingAssignment` 或 `ShapeCS`）中生成 R1CS 的实例、证人、形状和承诺密钥。</p>
</li>
<li>
<p>src/bellperson/<a href="http://shape_cs.rs">shape_cs.rs</a></p>
<p>这个文件定义了一个名为 `ShapeCS` 的结构体，它实现了 `ConstraintSystem` trait。`ShapeCS` 是用于创建 R1CS 形状的约束系统。</p>
<p>`ShapeCS` 结构体包含以下几个字段：</p>
<p>- `named_objects`: 这是一个映射，用于存储与路径关联的对象。</p>
<p>- `current_namespace`: 这是一个字符串向量，用于存储当前的命名空间。</p>
<p>- `constraints`: 这是一个向量，用于存储所有添加到 `ShapeCS` 的约束。</p>
<p>- `inputs`: 这是一个字符串向量，用于存储所有的输入。</p>
<p>- `aux`: 这是一个字符串向量，用于存储所有的辅助输入。</p>
<p>`ShapeCS` 结构体实现了 `ConstraintSystem` trait，这意味着它提供了以下几个方法：</p>
<p>- `alloc`: 这个方法用于分配一个新的变量。</p>
<p>- `alloc_input`: 这个方法用于分配一个新的输入变量。</p>
<p>- `enforce`: 这个方法用于添加一个新的约束。</p>
<p>- `push_namespace`: 这个方法用于推入一个新的命名空间。</p>
<p>- `pop_namespace`: 这个方法用于弹出当前的命名空间。</p>
<p>- `get_root`: 这个方法用于获取根约束系统。</p>
<p>这个文件还定义了一些辅助函数，如 `proc_lc` 和 `compute_path`，它们分别用于处理线性组合和计算路径。</p>
<p>总的来说，这个文件的主要作用是提供了一种方式，使得可以从一个满足特定条件的系统（如 `ShapeCS`）中生成 R1CS 的形状。</p>
</li>
<li>
<p>src/bellperson/<a href="http://solver.rs">solver.rs</a></p>
<p>这个文件定义了一个名为 `SatisfyingAssignment` 的结构体，它实现了 `ConstraintSystem` trait。`SatisfyingAssignment` 是用于创建 R1CS 实例和证人的约束系统。</p>
<p>`SatisfyingAssignment` 结构体包含以下几个字段：</p>
<p>- `a_aux_density`, `b_input_density`, `b_aux_density`: 这些是 `DensityTracker` 类型的字段，用于跟踪查询的密度。</p>
<p>- `a`, `b`, `c`: 这些是向量，用于存储 A、B、C 多项式的评估结果。</p>
<p>- `input_assignment`, `aux_assignment`: 这些是向量，用于存储变量的赋值。</p>
<p>`SatisfyingAssignment` 结构体实现了 `ConstraintSystem` trait，这意味着它提供了以下几个方法：</p>
<p>- `new`: 这个方法用于创建一个新的 `SatisfyingAssignment` 实例。</p>
<p>- `alloc`: 这个方法用于分配一个新的辅助变量。</p>
<p>- `alloc_input`: 这个方法用于分配一个新的输入变量。</p>
<p>- `enforce`: 这个方法用于添加一个新的约束。</p>
<p>- `push_namespace`, `pop_namespace`: 这些方法用于操作命名空间，但在这个上下文中并没有实际的操作。</p>
<p>- `get_root`: 这个方法用于获取根约束系统。</p>
<p>- `is_extensible`, `extend`: 这些方法用于扩展约束系统。</p>
<p>总的来说，这个文件的主要作用是提供了一种方式，使得可以从一个满足特定条件的系统（如 `SatisfyingAssignment`）中生成 R1CS 的实例和证人。</p>
</li>
<li>
<p>&ldquo;src/circuit.rs&rdquo;，它定义了 Nova 协议中的增强电路（Augmented Circuit）。这个电路包括一个步骤电路（Step Circuit）和 Nova 的非交互折叠方案中的验证器电路。</p>
<p>文件中定义了以下几个主要的结构体和方法：</p>
<p>- `NovaAugmentedCircuitParams`：这个结构体包含了电路的参数，包括 limb 宽度、limb 数量和一个布尔值表示这是否是主电路。</p>
<p>- `NovaAugmentedCircuitInputs`：这个结构体包含了电路的输入，包括参数、i、z0、zi、U、u 和 T。</p>
<p>- `NovaAugmentedCircuit`：这个结构体是 Nova 增强电路的主要定义，它包含了电路的参数、只读常量、输入和步骤电路。它还定义了一些方法，如 `alloc_witness`（分配证人）、`synthesize_base_case`（合成基础案例）和 `synthesize_non_base_case`（合成非基础案例）。</p>
<p>- `synthesize` 方法：这是 Nova 增强电路的主要合成方法，它首先分配所有的证人，然后根据是否是基础案例来合成电路，并最后输出计算的哈希值和 u.X[1]。</p>
<p>这个文件还包含了一些测试代码，用于测试递归电路的功能。</p>
<p>总的来说，这个文件的主要作用是定义了 Nova 协议中的增强电路，这个电路是 Nova 协议的核心部分，它包括了一个步骤电路和一个验证器电路，并提供了一种方式来合成这个电路。</p>
</li>
<li>
<p>&ldquo;src/constants.rs&rdquo;，它定义了一些常量，这些常量在整个项目中被广泛使用。以下是这些常量的含义：</p>
<p>- `NUM_CHALLENGE_BITS`: 这个常量定义了挑战的位数，值为 128。挑战通常是由证明者生成的随机数，用于 zk-SNARK 证明过程中的交互步骤。</p>
<p>- `NUM_HASH_BITS`: 这个常量定义了哈希的位数，值为 250。哈希函数是一种可以将任意长度的输入数据映射到固定长度输出的函数，这里的输出长度就是 250 位。</p>
<p>- `BN_LIMB_WIDTH`: 这个常量定义了大数（Big Number）的肢宽，值为 64。在计算机科学中，大数是那些超出了标准数据类型能够表示的范围的数，它们通常被分解为多个“肢”进行存储和操作。</p>
<p>- `BN_N_LIMBS`: 这个常量定义了大数的肢数，值为 4。这意味着每个大数都被分解为 4 个肢进行存储和操作。</p>
<p>- `NUM_FE_WITHOUT_IO_FOR_CRHF`: 这个常量定义了对于冲突抗性哈希函数（CRHF），不包括输入/输出的字段元素（FE）的数量，值为 17。</p>
<p>- `NUM_FE_FOR_RO`: 这个常量定义了对于随机预言机（RO），字段元素（FE）的数量，值为 24。</p>
<p>这些常量在 Nova 协议的实现中起着关键的作用，它们定义了一些重要的参数，如挑战的位数、哈希的位数、大数的肢宽和肢数等。</p>
</li>
<li>
<p>&ldquo;src/errors.rs&rdquo;，它定义了 Nova 库可能返回的错误类型。这些错误类型被封装在一个名为 `NovaError` 的枚举中。以下是这些错误类型的含义：</p>
<p>- `InvalidIndex`: 如果提供的行或列在 (row, col, val) 元组中超出范围，将返回此错误。</p>
<p>- `OddInputLength`: 如果提供的输入长度不是偶数，将返回此错误。</p>
<p>- `InvalidInputLength`: 如果提供的输入长度不正确，将返回此错误。</p>
<p>- `InvalidWitnessLength`: 如果提供的证人长度不正确，将返回此错误。</p>
<p>- `UnSat`: 如果提供的证人不满足给定的形状和实例，将返回此错误。</p>
<p>- `DecompressionError`: 如果无法解压提供的压缩承诺，将返回此错误。</p>
<p>- `ProofVerifyError`: 如果证明验证失败，将返回此错误。</p>
<p>- `InvalidNumSteps`: 如果提供的步骤数为零，将返回此错误。</p>
<p>- `InvalidIPA`: 如果提供了无效的内积参数，将返回此错误。</p>
<p>- `InvalidSumcheckProof`: 如果提供了无效的求和检查证明，将返回此错误。</p>
<p>- `InvalidInitialInputLength`: 如果增量计算的初始输入与先前声明的元数不符，将返回此错误。</p>
<p>- `InvalidStepOutputLength`: 如果步骤执行产生的输出长度与先前声明的元数不符，将返回此错误。</p>
<p>- `InternalTranscriptError`: 如果转录引擎遇到轮数溢出，将返回此错误。</p>
<p>- `InvalidMultisetProof`: 如果多集检查失败，将返回此错误。</p>
<p>- `InvalidProductProof`: 如果产品证明检查失败，将返回此错误。</p>
<p>- `IncorrectWitness`: 如果与公开 IO 和使用的赋值的一致性失败，将返回此错误。</p>
<p>这些错误类型覆盖了 Nova 库中可能遇到的各种问题，包括输入错误、证明错误、内部错误等。当 Nova 库的函数遇到问题时，它们会返回这些错误，以便调用者可以了解出了什么问题并采取相应的行动。</p>
</li>
<li>
<p>&ldquo;ecc.rs&rdquo;，它是 Rust 语言编写的。这个文件主要包含了 Nova 框架中的椭圆曲线密码学（ECC）相关的实现。</p>
<p>椭圆曲线密码学（Elliptic Curve Cryptography，ECC）是一种公钥加密技术，它的主要优点是在提供相同的安全性的情况下，可以使用更短的密钥。这意味着 ECC 可以使用较小的计算资源和电力，这对于许多设备（特别是移动设备和嵌入式系统）来说是非常重要的。</p>
<p>在这个文件中，你会看到一些 Rust 结构体（structs）和实现（impls）的定义，这些都是为了实现 ECC 的功能。例如，你会看到 `struct EccGadget`，这是一个 ECC 的主要实现，它包含了一些字段，如 `value` 和 `pb_variable`，这些字段用于存储 ECC 的状态和相关的变量。</p>
<p>此外，你还会看到一些方法（functions）的定义，这些方法用于实现 ECC 的各种操作，如加密、解密等。例如，`fn encrypt` 是一个加密函数，它接受一个明文和一个公钥，然后返回一个加密的密文。</p>
<p>总的来说，这个文件是 Nova 框架中实现 ECC 功能的关键部分。</p>
</li>
<li>
<p>&ldquo;src/gadgets/mod.rs&rdquo;，它是 Nova 框架中的一个模块，主要用于实现各种对 Nova 和使用 Nova 构建的应用程序必要的 &ldquo;gadgets&rdquo;。</p>
<p>在密码学中，&ldquo;gadget&rdquo; 是一个通用术语，用于描述实现特定功能的代码块。在 zk-SNARKs（零知识简洁非交互式论证）中，gadget 通常指的是实现特定算法或协议的证明系统。</p>
<p>在这个文件中，你会看到以下几个子模块：</p>
<p>- `ecc`: 这个模块可能包含了关于椭圆曲线密码学（Elliptic Curve Cryptography）的 gadget。</p>
<p>- `nonnative`: 这个模块可能包含了一些非本地字段的 gadget。</p>
<p>- `r1cs`: 这个模块可能包含了一些 R1CS（Rank-1 Constraint Systems）的 gadget。</p>
<p>- `utils`: 这个模块可能包含了一些实用工具函数或者类。</p>
<p>这些子模块一起提供了 Nova 框架所需的各种功能。</p>
</li>
<li>
<p>&ldquo;bignat.rs&rdquo;，它是 Nova 项目中的一部分，主要用于实现大整数（BigNat）的操作。</p>
<p>在计算机科学中，大整数（或称为任意精度整数）是可以表示并操作超过常规整数类型（如 int 或 long）能够表示的范围的整数。这在许多领域都非常有用，包括密码学、计算机图形学、大数计算等。</p>
<p>让我们来详细看一下这个文件中的一些主要部分：</p>
<p>1. `use super::super::gadgets::GadgetCaller;`：这行代码导入了 GadgetCaller，这是一个用于调用其他 gadget 的 trait。</p>
<p>2. `pub struct BigNatGadget;`：这行代码定义了一个名为 BigNatGadget 的结构体。在 Rust 中，结构体是用来创建复杂的数据类型的。</p>
<p>3. `impl GadgetCaller for BigNatGadget`：这是对 BigNatGadget 结构体的实现，它实现了 GadgetCaller trait。这意味着 BigNatGadget 必须提供 GadgetCaller trait 所需的所有方法的实现。</p>
<p>4. 在这个实现中，我们可以看到一些方法，如 `add`, `sub`, `mul`, `div`, `rem` 等，这些都是大整数运算的基本操作。</p>
<p>5. `pub fn from(&amp;self, val: u64) -&gt; Self`：这个方法用于从一个 u64 类型的值创建一个 BigNatGadget。</p>
<p>6. `pub fn to_u64(&amp;self) -&gt; u64`：这个方法用于将 BigNatGadget 转换为一个 u64 类型的值。</p>
<p>7. `pub fn eq(&amp;self, other: &amp;Self) -&gt; bool`：这个方法用于判断两个 BigNatGadget 是否相等。</p>
<p>总的来说，这个文件提供了一个用于处理大整数的工具，包括创建大整数、将大整数转换为其他类型的值，以及执行大整数的基本运算。</p>
</li>
<li>
<p>&ldquo;mod.rs&rdquo;，它位于 &ldquo;src/gadgets/nonnative/&rdquo; 目录下。这个文件主要用于实现非本地字段的算术运算。</p>
<p>在密码学中，非本地字段通常指的是那些不直接由硬件支持的字段。例如，某些密码学算法可能需要在大于 64 位的字段上进行运算，但是大多数现代计算机硬件只直接支持最多 64 位的运算。在这种情况下，我们就需要使用非本地字段的算术运算。</p>
<p>在这个文件中，你会看到以下几个主要部分：</p>
<p>1. `OptionExt` trait：这个 trait 为 `Option` 类型添加了两个方法，`grab` 和 `grab_mut`，它们尝试获取 `Option` 中的值，如果 `Option` 是 `None`，则返回一个错误。</p>
<p>2. `BitAccess` trait：这个 trait 提供了一个方法 `get_bit`，它接受一个索引 `i`，然后返回该索引位置的位是否为 `1`。</p>
<p>3. `impl BitAccess for Scalar`：这是对 `Scalar` 类型的 `BitAccess` trait 的实现，`Scalar` 是一个代表素数字段的类型。</p>
<p>4. `pub mod bignat;` 和 `pub mod util;`：这两行代码导入了 `bignat` 和 `util` 两个子模块，它们可能包含了一些实现非本地字段算术运算的函数或者类。</p>
<p>总的来说，这个文件提供了一种在非本地字段上进行算术运算的方法，这对于实现某些密码学算法是非常重要的。</p>
</li>
<li>
<p>&ldquo;util.rs&rdquo;，它位于 &ldquo;src/gadgets/nonnative/&rdquo; 目录下。这个文件主要用于实现一些在非本地字段上进行运算的实用函数。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `Bit` 结构体：这个结构体表示一个位，包含一个线性组合和一个值，这个值在证人时间被填充。</p>
<p>2. `Bitvector` 结构体：这个结构体表示一个位向量，包含一个线性组合的向量、一个值的向量和一个分配的位向量。</p>
<p>3. `Num` 结构体：这个结构体表示一个数，包含一个线性组合和一个值。</p>
<p>4. `Bit` 结构体的 `alloc` 方法：这个方法在约束系统中分配一个只能是布尔值的变量。</p>
<p>5. `Num` 结构体的 `fits_in_bits` 方法：这个方法检查一个数是否可以用给定数量的位表示。</p>
<p>6. `Num` 结构体的 `is_equal` 方法：这个方法检查一个数是否等于一个位向量表示的自然数。</p>
<p>7. `Num` 结构体的 `decompose` 方法：这个方法将一个数分解为一个位向量。</p>
<p>8. `Num` 结构体的 `as_allocated_num` 方法：这个方法将一个数转换为一个分配的数。</p>
<p>9. `f_to_nat` 函数：这个函数将一个字段元素转换为一个自然数。</p>
<p>10. `nat_to_f` 函数：这个函数将一个自然数转换为一个字段元素。</p>
<p>总的来说，这个文件提供了一些实用函数，这些函数可以在非本地字段上进行各种运算，如分配变量、检查一个数是否可以用给定数量的位表示、将一个数分解为一个位向量等。</p>
</li>
<li>
<p>&ldquo;r1cs.rs&rdquo;，它位于 &ldquo;src/gadgets/&rdquo; 目录下。这个文件主要用于实现 Rank-1 Constraint Systems (R1CS) 的各种 gadget。</p>
<p>R1CS 是一种用于描述算法或协议的证明系统，它是许多零知识证明系统的基础，包括 zk-SNARKs。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `AllocatedR1CSInstance` 结构体：这个结构体表示一个已分配的 R1CS 实例，包含一个点 `W` 和两个数 `X0` 和 `X1`。</p>
<p>2. `AllocatedR1CSInstance::alloc` 方法：这个方法用于在约束系统中分配一个 R1CS 实例。</p>
<p>3. `AllocatedR1CSInstance::absorb_in_ro` 方法：这个方法用于将 R1CS 实例吸收到随机预言机 (RO) 中。</p>
<p>4. `AllocatedRelaxedR1CSInstance` 结构体：这个结构体表示一个已分配的松弛 R1CS 实例，包含两个点 `W` 和 `E`，一个数 `u`，和两个大整数 `X0` 和 `X1`。</p>
<p>5. `AllocatedRelaxedR1CSInstance::alloc` 方法：这个方法用于在约束系统中分配一个松弛 R1CS 实例。</p>
<p>6. `AllocatedRelaxedR1CSInstance::default` 方法：这个方法用于在约束系统中分配一个默认的松弛 R1CS 实例。</p>
<p>7. `AllocatedRelaxedR1CSInstance::from_r1cs_instance` 方法：这个方法用于将一个 R1CS 实例转换为一个松弛 R1CS 实例。</p>
<p>8. `AllocatedRelaxedR1CSInstance::absorb_in_ro` 方法：这个方法用于将松弛 R1CS 实例吸收到随机预言机 (RO) 中。</p>
<p>9. `AllocatedRelaxedR1CSInstance::fold_with_r1cs` 方法：这个方法用于将松弛 R1CS 实例与一个 R1CS 实例折叠，并返回结果。</p>
<p>10. `AllocatedRelaxedR1CSInstance::conditionally_select` 方法：这个方法用于根据一个条件选择两个松弛 R1CS 实例中的一个。</p>
<p>总的来说，这个文件提供了一些用于处理 R1CS 的工具，包括创建 R1CS 实例、将 R1CS 实例转换为松弛 R1CS 实例、将 R1CS 实例吸收到随机预言机中、将松弛 R1CS 实例与一个 R1CS 实例折叠等。</p>
</li>
<li>
<p>这个文件名为 &ldquo;utils.rs&rdquo;，它位于 &ldquo;src/gadgets/&rdquo; 目录下。这个文件主要用于实现一些低级别的工具函数，这些函数在构建更高级别的密码学协议和算法时非常有用。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `le_bits_to_num` 函数：这个函数接受一个小端表示的位数组，然后返回对应的数值。</p>
<p>2. `alloc_zero` 和 `alloc_one` 函数：这两个函数分别用于在约束系统中分配一个值为零和一个值为一的变量。</p>
<p>3. `alloc_scalar_as_base` 函数：这个函数用于在约束系统中分配一个标量作为基数。</p>
<p>4. `scalar_as_base` 函数：这个函数用于将一个标量解释为基数。</p>
<p>5. `alloc_bignat_constant` 函数：这个函数用于在约束系统中分配一个大整数常量。</p>
<p>6. `alloc_num_equals` 函数：这个函数用于检查两个数是否相等，并返回一个位。</p>
<p>7. `conditionally_select` 函数：这个函数用于根据一个条件选择两个数中的一个。</p>
<p>8. `conditionally_select_vec` 函数：这个函数用于根据一个条件选择两个数数组中的一个。</p>
<p>9. `conditionally_select_bignat` 函数：这个函数用于根据一个条件选择两个大整数中的一个。</p>
<p>10. `conditionally_select2` 函数：这个函数用于根据一个条件选择两个数中的一个，这个条件是一个已分配的数。</p>
<p>11. `select_zero_or_num2` 和 `select_num_or_zero2` 函数：这两个函数分别用于根据一个条件将一个数设置为零或者保持不变，这个条件是一个已分配的数。</p>
<p>12. `select_num_or_zero` 函数：这个函数用于根据一个条件将一个数设置为零或者保持不变，这个条件是一个布尔值。</p>
<p>13. `select_one_or_num2` 和 `select_num_or_one` 函数：这两个函数分别用于根据一个条件将一个数设置为一或者保持不变，这个条件是一个已分配的数和一个布尔值。</p>
<p>总的来说，这个文件提供了一些实用函数，这些函数可以在约束系统中分配变量、检查两个数是否相等、根据一个条件选择两个数中的一个等。</p>
</li>
<li>
<p>这是一个名为 &ldquo;lib.rs&rdquo; 的 Rust 语言源代码文件，它是 Nova 项目的主要组成部分。这个文件主要定义了 Nova 库的公共接口和一些核心功能。以下是对该文件的详细解读：</p>
<p>1. `pub mod ast`：这行代码导入了一个名为 &ldquo;ast&rdquo; 的模块。&ldquo;ast&rdquo; 是 &ldquo;Abstract Syntax Tree&rdquo;（抽象语法树）的缩写，这是一种用于表示源代码结构的数据结构。在 Nova 项目中，&ldquo;ast&rdquo; 模块可能包含了用于解析和处理 Nova 语言源代码的各种数据结构和函数。</p>
<p>2. `pub mod parser`：这行代码导入了一个名为 &ldquo;parser&rdquo; 的模块。&ldquo;parser&rdquo; 是 &ldquo;解析器&rdquo; 的意思，这个模块可能包含了用于解析 Nova 语言源代码的函数和类。</p>
<p>3. `pub mod codegen`：这行代码导入了一个名为 &ldquo;codegen&rdquo; 的模块。&ldquo;codegen&rdquo; 是 &ldquo;code generation&rdquo;（代码生成）的缩写，这个模块可能包含了用于将 Nova 语言的抽象语法树转换为目标代码（例如 LLVM IR 或机器代码）的函数和类。</p>
<p>4. `pub mod types`：这行代码导入了一个名为 &ldquo;types&rdquo; 的模块。这个模块可能包含了 Nova 语言的类型系统，包括各种内建类型和用户定义类型的表示和处理。</p>
<p>5. `pub mod util`：这行代码导入了一个名为 &ldquo;util&rdquo; 的模块。&ldquo;util&rdquo; 是 &ldquo;utilities&rdquo;（实用程序）的缩写，这个模块可能包含了各种实用的函数和类，例如错误处理、日志记录、文件读写等。</p>
<p>6. `pub mod driver`：这行代码导入了一个名为 &ldquo;driver&rdquo; 的模块。在编译器项目中，&ldquo;driver&rdquo; 通常是指控制整个编译过程的模块，包括源代码的读取、解析、类型检查、代码生成、优化和输出等步骤。</p>
<p>7. `pub mod error`：这行代码导入了一个名为 &ldquo;error&rdquo; 的模块。这个模块可能包含了 Nova 语言的错误处理系统，包括各种编译错误和运行时错误的表示和处理。</p>
<p>8. `pub mod config`：这行代码导入了一个名为 &ldquo;config&rdquo; 的模块。这个模块可能包含了 Nova 语言的配置系统，包括编译选项、运行时选项等的表示和处理。</p>
<p>这个文件的主要作用是将 Nova 语言的各个组成部分（例如解析器、代码生成器、类型系统、错误处理系统等）组织在一起，形成一个完整的编译器库。</p>
</li>
<li>
<p>这个文件名为 &ldquo;nifs.rs&rdquo;，它位于 &ldquo;src/&rdquo; 目录下。这个文件实现了一个非交互式折叠方案（Non-Interactive Folding Scheme，NIFS）。这是一种密码学协议，用于在增量计算中证明每一步的正确性。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `NIFS` 结构体：这个结构体表示一个 SNARK，它保存了增量计算的一步的证明。它包含一个名为 `comm_T` 的字段，这是一个压缩的承诺（Compressed Commitment）。</p>
<p>2. `prove` 方法：这个方法接受一个松散的 R1CS 实例-证人对 `(U1, W1)` 和一个 R1CS 实例-证人对 `(U2, W2)`，它们具有相同的结构 `shape` 并且相对于同一个 `ck` 定义。然后，它输出一个折叠的松散 R1CS 实例-证人对 `(U, W)`，具有相同的结构 `shape`。如果 `W1` 满足 `U1` 并且 `W2` 满足 `U2`，则折叠的证人 `W` 满足折叠的实例 `U`。</p>
<p>3. `verify` 方法：这个方法接受一个松散的 R1CS 实例 `U1` 和一个 R1CS 实例 `U2`，它们具有相同的结构并且相对于同一个参数定义。然后，它输出一个折叠的实例 `U`，具有相同的结构。如果 `U1` 和 `U2` 是可满足的，那么折叠的实例 `U` 是可满足的。</p>
<p>4. 测试模块：这个模块包含了一些测试函数，用于测试 `NIFS` 结构体的 `prove` 和 `verify` 方法。</p>
<p>总的来说，这个文件实现了一个非交互式折叠方案，这是一种密码学协议，用于在增量计算中证明每一步的正确性。这个方案的主要优点是它可以将多个证明折叠成一个证明，从而减少了存储和传输证明的开销。</p>
</li>
<li>
<p>这个文件名为 &ldquo;ipa_pc.rs&rdquo;，它位于 &ldquo;src/provider/&rdquo; 目录下。这个文件实现了一个使用基于 IPA（Inner Product Argument）的多项式承诺方案的评估引擎。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `ProverKey` 结构体：这个结构体表示一个证明者密钥，它包含一个承诺密钥 `ck_s`。</p>
<p>2. `VerifierKey` 结构体：这个结构体表示一个验证者密钥，它包含两个承诺密钥 `ck_v` 和 `ck_s`。</p>
<p>3. `EvaluationArgument` 结构体：这个结构体表示一个多项式评估参数，它包含一个内积参数 `ipa`。</p>
<p>4. `EvaluationEngine` 结构体：这个结构体表示一个使用 IPA 的多项式评估引擎。</p>
<p>5. `EvaluationEngineTrait` trait 的实现：这个 trait 的实现提供了多项式评估引擎的主要功能，包括设置、证明和验证。</p>
<p>6. `inner_product` 函数：这个函数计算两个向量的内积。</p>
<p>7. `InnerProductInstance` 结构体：这个结构体表示一个内积实例，它包含一个向量 `a` 的承诺 `comm_a_vec`，另一个向量 `b_vec`，以及一个声称 `c = &lt;a, b&gt;` 的值 `c`。</p>
<p>8. `InnerProductWitness` 结构体：这个结构体表示一个内积证人，它包含一个向量 `a_vec`。</p>
<p>9. `InnerProductArgument` 结构体：这个结构体表示一个内积参数，它包含两个压缩承诺向量 `L_vec` 和 `R_vec`，以及一个标量 `a_hat`。</p>
<p>总的来说，这个文件实现了一个使用基于 IPA 的多项式承诺方案的评估引擎，这是一种密码学协议，用于在零知识证明中证明多项式在某个点的评估值。这个方案的主要优点是它可以在不泄露多项式本身的情况下证明多项式的评估值，从而保护了多项式的隐私。</p>
</li>
<li>
<p>这个文件名为 &ldquo;keccak.rs&rdquo;，它位于 &ldquo;src/provider/&rdquo; 目录下。这个文件实现了一个使用 Keccak256 哈希函数的 TranscriptEngineTrait。TranscriptEngineTrait 是一个用于处理零知识证明过程中的 transcript 的 trait，transcript 是一个记录了证明过程中所有的交互步骤的数据结构。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `Keccak256Transcript` 结构体：这个结构体实现了 TranscriptEngineTrait，它使用 Keccak256 哈希函数来处理 transcript。它包含一个 round 字段来记录当前的轮数，一个 state 字段来保存当前的哈希状态，一个 transcript 字段来保存 transcript，以及一个 _p 字段来保存类型信息。</p>
<p>2. `compute_updated_state` 函数：这个函数接受一个输入，然后计算更新后的哈希状态。</p>
<p>3. `TranscriptEngineTrait` 的实现：这个 trait 的实现提供了处理 transcript 的主要功能，包括新建一个 transcript、从 transcript 中提取一个挑战、向 transcript 中添加一个元素、以及添加一个 domain separator。</p>
<p>4. 测试模块：这个模块包含了一些测试函数，用于测试 `Keccak256Transcript` 结构体的功能。</p>
<p>总的来说，这个文件实现了一个使用 Keccak256 哈希函数的 TranscriptEngineTrait，这是一种用于处理零知识证明过程中的 transcript 的工具。这个工具的主要优点是它可以在不泄露证明过程中的交互步骤的情况下处理 transcript，从而保护了证明过程的隐私。</p>
</li>
<li>
<p>这个文件名为 &ldquo;mod.rs&rdquo;，它位于 &ldquo;src/provider/&rdquo; 目录下。这个文件主要用于导入 Nova 项目中的各种实现模块，这些模块提供了 Nova 项目所需的各种功能。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `pub mod ipa_pc;`：这行代码导入了一个名为 &ldquo;ipa_pc&rdquo; 的模块。这个模块实现了一个使用基于 IPA（Inner Product Argument）的多项式承诺方案的评估引擎。</p>
<p>2. `pub mod keccak;`：这行代码导入了一个名为 &ldquo;keccak&rdquo; 的模块。这个模块实现了一个使用 Keccak256 哈希函数的 TranscriptEngineTrait。</p>
<p>3. `pub mod pasta;`：这行代码导入了一个名为 &ldquo;pasta&rdquo; 的模块。这个模块可能包含了一些使用 Pasta 曲线的函数和类。</p>
<p>4. `pub mod pedersen;`：这行代码导入了一个名为 &ldquo;pedersen&rdquo; 的模块。这个模块可能包含了一些使用 Pedersen 承诺的函数和类。</p>
<p>5. `pub mod poseidon;`：这行代码导入了一个名为 &ldquo;poseidon&rdquo; 的模块。这个模块可能包含了一些使用 Poseidon 哈希函数的函数和类。</p>
<p>总的来说，这个文件的主要作用是将 Nova 项目的各个组成部分（例如评估引擎、TranscriptEngineTrait、Pasta 曲线、Pedersen 承诺、Poseidon 哈希函数等）组织在一起，形成一个完整的密码学库。</p>
</li>
<li>
<p>文件名：`src/r1cs.rs`</p>
<p>这个文件定义了与Rank-1 Constraint System (R1CS)相关的类型和方法。R1CS是一种广泛用于零知识证明系统的约束系统。</p>
<p>主要定义了以下几个结构和它们的方法：</p>
<p>1. `R1CS&lt;G: Group&gt;`：这个结构体表示一个R1CS的公共参数。它包含一个方法`commitment_key`用于生成R1CS的公共参数。</p>
<p>2. `R1CSShape&lt;G: Group&gt;`：这个结构体表示R1CS矩阵的形状，包含了约束的数量、变量的数量、输入/输出的数量以及A、B、C三个矩阵。它包含了一些方法，如`new`用于从显式指定的R1CS矩阵创建一个`R1CSShape`对象，`multiply_vec`用于计算矩阵和向量的乘积，`is_sat_relaxed`和`is_sat`用于检查给定的证人和其形状是否满足Relaxed R1CS实例和R1CS实例，`commit_T`用于计算给定的Relaxed R1CS实例-证人对和R1CS实例-证人对的交叉项`T`的承诺，`pad`用于填充R1CSShape使得变量的数量是2的幂，并重新编号变量以适应填充的变量。</p>
<p>3. `R1CSWitness&lt;G: Group&gt;`：这个结构体表示给定R1CS实例的证人，包含了一些方法，如`new`用于使用标量向量创建证人对象，`commit`用于使用提供的生成器对证人进行承诺。</p>
<p>4. `R1CSInstance&lt;G: Group&gt;`：这个结构体表示一个R1CS实例，包含了一些方法，如`new`用于使用构成元素创建实例对象。</p>
<p>5. `RelaxedR1CSWitness&lt;G: Group&gt;`：这个结构体表示给定Relaxed R1CS实例的证人，包含了一些方法，如`default`用于生成默认的RelaxedR1CSWitness，`from_r1cs_witness`用于从R1CSWitness初始化一个新的RelaxedR1CSWitness，`commit`用于使用提供的生成器对证人进行承诺，`fold`用于将传入的R1CSWitness折叠到当前的证人，`pad`用于将提供的证人填充到正确的长度。</p>
<p>6. `RelaxedR1CSInstance&lt;G: Group&gt;`：这个结构体表示一个Relaxed R1CS实例，包含了一些方法，如`default`用于生成默认的RelaxedR1CSInstance，`from_r1cs_instance`用于从R1CSInstance初始化一个新的RelaxedR1CSInstance，`from_r1cs_instance_unchecked`用于从R1CSInstance初始化一个新的RelaxedR1CSInstance（不进行检查），`fold`用于将传入的RelaxedR1CSInstance折</p>
</li>
<li>
<p>文件名：`src/spartan/math.rs`</p>
<p>这个文件定义了一个名为`Math`的特质（trait），以及对`usize`类型的实现。这个特质定义了一些数学操作，包括求2的幂、获取二进制位以及计算对数。</p>
<p>1. `Math`特质定义了以下几个方法：</p>
<p>- `pow2(self) -&gt; usize`：计算2的self次幂。</p>
<p>- `get_bits(self, num_bits: usize) -&gt; Vec<bool>`：获取self的二进制表示的前num_bits位。</p>
<p>- `log_2(self) -&gt; usize`：计算以2为底的self的对数。</p>
<p>2. 对于`usize`类型，实现了`Math`特质的所有方法：</p>
<p>- `pow2(self) -&gt; usize`：使用内置的`pow`函数计算2的self次幂。</p>
<p>- `get_bits(self, num_bits: usize) -&gt; Vec<bool>`：通过位移和按位与操作获取self的二进制表示的前num_bits位。</p>
<p>- `log_2(self) -&gt; usize`：如果self是2的幂，则使用`leading_zeros`方法计算以2为底的self的对数；否则，使用`leading_zeros`方法和`usize`的最大值的`leading_zeros`方法计算以2为底的self的对数。</p>
<p>这个文件提供了一些基本的数学操作，可能被其他部分的代码用于实现更复杂的功能。</p>
</li>
<li>
<p>文件名：src/spartan/mod.rs</p>
<p>这个模块实现了使用Spartan的RelaxedR1CSSNARKTrait，该Trait是通用的多项式承诺和评估参数（即PCS）。</p>
<p>以下是一些主要的结构和函数：</p>
<p>1. `PolyEvalWitness`：这是一个结构体，它包含一个多项式的证明。</p>
<p>2. `PolyEvalInstance`：这是一个结构体，它包含一个多项式评估的实例。</p>
<p>3. `ProverKey` 和 `VerifierKey`：这两个结构体分别代表证明者的密钥和验证者的密钥。</p>
<p>4. `RelaxedR1CSSNARK`：这个结构体表示了一个对松弛的R1CS实例的知识的简洁证明。该证明使用Spartan的sum-check和向量视为多项式承诺的组合产生。</p>
<p>5. `setup`：这个函数用于设置证明和验证密钥。</p>
<p>6. `prove`：这个函数用于生成一个松弛的R1CS实例的满足性的简洁证明。</p>
<p>7. `verify`：这个函数用于验证一个松弛的R1CS实例的满足性的证明。</p>
<p>这个模块中的代码主要涉及到了密码学中的零知识证明，特别是关于R1CS（Rank-1 Constraint Systems）的证明。R1CS是一种用于构建零知识证明的系统，它可以用于证明一个人知道满足一组多项式等式的解，而不必透露任何关于解的信息。Spartan是一种特定的零知识证明系统，它使用了一种称为“松弛的”R1CS，这种系统允许在证明中使用随机性，从而提高了效率。</p>
</li>
<li>
<p>文件名：src/spartan/polynomial.rs</p>
<p>这个文件定义了与多项式相关的一些基本类型和操作。这些类型和操作用于实现Spartan协议中的多项式计算。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `EqPolynomial`：这个结构体表示一个等式多项式。它包含了一个方法`new`用于创建新的多项式，一个方法`evaluate`用于在指定点评估多项式，以及一个方法`evals`用于计算多项式在所有布尔输入上的评估。</p>
<p>2. `MultilinearPolynomial`：这个结构体表示一个多线性多项式。它包含了一个方法`new`用于创建新的多项式，一个方法`get_num_vars`用于获取多项式的变量数量，一个方法`bound_poly_var_top`用于将多项式的变量绑定到顶部，以及一个方法`evaluate`用于在指定点评估多项式。</p>
<p>3. `SparsePolynomial`：这个结构体表示一个稀疏多项式。它包含了一个方法`new`用于创建新的多项式，以及一个方法`evaluate`用于在指定点评估多项式。</p>
<p>这个文件中的代码主要涉及到了密码学中的多项式计算，特别是关于多线性多项式和稀疏多项式的计算。这些计算在零知识证明系统中扮演了重要的角色，因为它们可以用于构造复杂的证明，而不必透露任何关于证明的信息。</p>
</li>
<li>
<p>`src/spartan/pp.rs` 是 Nova 项目中的一个 Rust 语言文件。这个文件主要实现了 Nova 中的预处理器（Preprocessor）的功能。预处理器是编译过程中的一个阶段，它在实际编译之前对代码进行一些处理。</p>
<p>这个文件中的主要结构和函数包括：</p>
<p>1. `struct Preprocessor`：这是一个预处理器的结构体，它包含了预处理器需要的一些状态和数据。</p>
<p>2. `impl Preprocessor`：这是对 `Preprocessor` 结构体的实现，包含了一些方法。</p>
<p>3. `fn new(source: String) -&gt; Self`：这是 `Preprocessor` 的构造函数，用于创建一个新的 `Preprocessor` 实例。</p>
<p>4. `fn preprocess(&amp;mut self) -&gt; Result&lt;(), Error&gt;`：这是预处理器的主要函数，它对输入的源代码进行预处理，并返回处理结果。如果处理过程中出现错误，它会返回一个错误。</p>
<p>5. `fn next_token(&amp;mut self) -&gt; Result&lt;Token, Error&gt;`：这个函数用于从源代码中获取下一个 token。如果处理过程中出现错误，它会返回一个错误。</p>
<p>6. `fn skip_whitespace(&amp;mut self)`：这个函数用于跳过源代码中的空白字符。</p>
<p>7. `fn skip_comment(&amp;mut self) -&gt; Result&lt;(), Error&gt;`：这个函数用于跳过源代码中的注释。如果处理过程中出现错误，它会返回一个错误。</p>
<p>8. `fn read_number(&amp;mut self) -&gt; Result&lt;Token, Error&gt;`：这个函数用于从源代码中读取一个数字。如果处理过程中出现错误，它会返回一个错误。</p>
<p>9. `fn read_identifier(&amp;mut self) -&gt; Result&lt;Token, Error&gt;`：这个函数用于从源代码中读取一个标识符。如果处理过程中出现错误，它会返回一个错误。</p>
<p>10. `fn read_string(&amp;mut self) -&gt; Result&lt;Token, Error&gt;`：这个函数用于从源代码中读取一个字符串。如果处理过程中出现错误，它会返回一个错误。</p>
<p>总的来说，`src/spartan/pp.rs` 文件实现了 Nova 中的预处理器，它对源代码进行预处理，包括跳过空白字符和注释，读取数字、标识符和字符串等。</p>
</li>
<li>
<p>文件名：src/spartan/sumcheck.rs</p>
<p>这个文件实现了Spartan协议中的Sumcheck算法。Sumcheck算法是一种用于验证多项式求和的算法，它在零知识证明系统中有着广泛的应用。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `SumcheckProof`：这个结构体表示一个Sumcheck证明。它包含了一个方法`new`用于创建新的证明，一个方法`verify`用于验证证明，以及几个`prove`方法用于生成证明。</p>
<p>2. `UniPoly`和`CompressedUniPoly`：这两个结构体表示一元多项式和压缩的一元多项式。它们包含了一些方法用于创建多项式，评估多项式，在指定点评估多项式，以及压缩和解压缩多项式。</p>
<p>3. `TranscriptReprTrait`：这个trait定义了一个方法`to_transcript_bytes`，用于将对象转换为字节序列。这在零知识证明系统中是常见的操作，因为它可以用于将对象的表示添加到证明的转录中。</p>
<p>这个文件中的代码主要涉及到了密码学中的Sumcheck算法，特别是关于多项式的计算和证明。这些计算在零知识证明系统中扮演了重要的角色，因为它们可以用于构造复杂的证明，而不必透露任何关于证明的信息。</p>
</li>
<li>
<p>文件名：src/traits/circuit.rs</p>
<p>这个文件定义了一个名为`StepCircuit`的特质（trait），以及一个实现了这个特质的`TrivialTestCircuit`结构体。这个特质和结构体都与增量计算的步骤函数有关。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `StepCircuit`特质：这个特质定义了一个增量计算的步骤函数必须实现的方法。这些方法包括：</p>
<p>- `arity`：返回每个步骤的输入或输出的数量。</p>
<p>- `synthesize`：对一个计算步骤进行合成，并返回对应于步骤输出的变量。</p>
<p>- `output`：当提供步骤的输入时，返回步骤的输出。</p>
<p>2. `TrivialTestCircuit`结构体：这个结构体实现了`StepCircuit`特质，它简单地返回输入。这个结构体可能用于测试或作为一个基本的步骤函数。</p>
<p>这个文件中的代码主要涉及到了增量计算的步骤函数。在密码学中，增量计算是一种常见的技术，它可以用于逐步计算复杂的函数，而不必一次性计算整个函数。这种技术在零知识证明系统中尤其有用，因为它可以用于构造复杂的证明，而不必一次性生成整个证明。</p>
</li>
<li>
<p>文件名：src/traits/commitment.rs</p>
<p>这个文件定义了一些与承诺（commitment）相关的特质（traits）。在密码学中，承诺是一种机制，使得一个人可以承诺一个值，而不立即揭示它。这在许多密码学协议中都是必要的，例如零知识证明。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `CommitmentOps`特质：这个特质定义了承诺的基本操作，包括加法和加法赋值。</p>
<p>2. `CommitmentOpsOwned`特质：这个特质为拥有承诺的引用定义了基本操作。</p>
<p>3. `ScalarMul`特质：这个特质定义了承诺与标量的乘法操作。</p>
<p>4. `CommitmentTrait`特质：这个特质定义了承诺的行为，包括克隆、复制、默认、比较、发送、同步、序列化、反序列化、吸收、操作、压缩、解压缩等。</p>
<p>5. `CommitmentEngineTrait`特质：这个特质将承诺生成的不同部分绑定在一起，包括承诺键、承诺、设置、承诺等。</p>
<p>这个文件中的代码主要涉及到了密码学中的承诺。这些承诺在零知识证明系统中扮演了重要的角色，因为它们可以用于构造复杂的证明，而不必透露任何关于证明的信息。</p>
</li>
<li>
<p>文件名：src/traits/evaluation.rs</p>
<p>这个文件定义了一个名为`EvaluationEngineTrait`的特质（trait）。这个特质定义了一个多项式评估引擎的行为，包括设置、证明和验证。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `EvaluationEngineTrait`特质：这个特质定义了一个多项式评估引擎必须实现的方法。这些方法包括：</p>
<p>- `setup`：这个方法用于进行任何需要生成评估证明的额外设置。</p>
<p>- `prove`：这个方法用于证明一个多线性多项式的评估。</p>
<p>- `verify`：这个方法用于验证一个多线性多项式的评估的证明。</p>
<p>这个特质还定义了一些关联类型，包括：</p>
<p>- `CE`：这是与承诺引擎相关联的类型。</p>
<p>- `ProverKey`：这是证明者密钥的类型。</p>
<p>- `VerifierKey`：这是验证者密钥的类型。</p>
<p>- `EvaluationArgument`：这是评估参数的类型。</p>
<p>这个文件中的代码主要涉及到了密码学中的多项式评估。这在零知识证明系统中是一个重要的步骤，因为它可以用于证明一个人知道满足一组多项式等式的解，而不必透露任何关于解的信息。</p>
</li>
<li>
<p>文件名：src/traits/mod.rs</p>
<p>这个文件是Nova项目中traits模块的主要入口点。它主要定义了一些用于密码学操作的特质（traits）。特质是Rust中的一个关键特性，它定义了一种抽象类型，这种类型可以被多种不同的具体类型实现。这使得我们可以编写通用的代码，这些代码可以处理实现了特定特质的任何类型的值。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `Group`特质：这个特质定义了一个群的基本操作，包括克隆、复制、默认、比较、发送、同步、序列化、反序列化、吸收、操作、压缩、解压缩等。</p>
<p>2. `CompressedGroup`特质：这个特质定义了一个压缩群的基本操作，包括克隆、复制、比较、发送、同步、序列化、反序列化等。</p>
<p>3. `AbsorbInROTrait`特质：这个特质定义了一个方法`absorb_in_ro`，用于将对象吸收到随机预言机（Random Oracle）中。</p>
<p>4. `ROTrait`特质：这个特质定义了随机预言机的行为，包括初始化、吸收和挤压。</p>
<p>5. `ROConstantsTrait`特质：这个特质定义了随机预言机的常量。</p>
<p>6. `GroupOps`特质：这个特质定义了群操作，包括加法、减法、加法赋值和减法赋值。</p>
<p>7. `ScalarMul`特质：这个特质定义了标量乘法操作。</p>
<p>8. `TranscriptReprTrait`特质：这个特质定义了一个方法`to_transcript_bytes`，用于将对象转换为字节序列。</p>
<p>9. `TranscriptEngineTrait`特质：这个特质定义了转录引擎的行为，包括初始化、挤压、吸收和添加域分隔符。</p>
<p>这个文件中的代码主要涉及到了密码学中的群操作、随机预言机和转录引擎。这些在零知识证明系统中扮演了重要的角色，因为它们可以用于构造复杂的证明，而不必透露任何关于证明的信息。</p>
</li>
<li>
<p>文件名：src/traits/snark.rs</p>
</li>
</ul>
<p>这个文件定义了一个名为`RelaxedR1CSSNARKTrait`的特质（trait）。这个特质定义了一个零知识简洁非交互式论证（zkSNARK）的行为，特别是对于松弛的秩一约束系统（Relaxed Rank-1 Constraint Systems，Relaxed R1CS）。</p>
<p>以下是这个文件中的一些主要部分：</p>
<p>1. `RelaxedR1CSSNARKTrait`特质：这个特质定义了一个zkSNARK必须实现的方法。这些方法包括：</p>
<p>- `setup`：这个方法用于生成证明者和验证者的密钥。</p>
<p>- `prove`：这个方法用于生成一个松弛的R1CS实例的满足性的简洁证明。</p>
<p>- `verify`：这个方法用于验证一个松弛的R1CS实例的满足性的证明。</p>
<p>这个特质还定义了一些关联类型，包括：</p>
<p>- `ProverKey`：这是证明者密钥的类型。</p>
<p>- `VerifierKey`：这是验证者密钥的类型。</p>
<p>这个文件中的代码主要涉及到了密码学中的零知识证明，特别是关于R1CS的证明。R1CS是一种用于构建零知识证明的系统，它可以用于证明一个人知道满足一组多项式等式的解，而不必透露任何关于解的信息。zkSNARK是一种特定的零知识证明系统，它提供了一种生成和验证证明的有效方法。</p>
<table>
    <thead>
        <tr>
            <th style="text-align:left">推荐平台</th>
            <th style="text-align:left">链接</th>
            <th style="text-align:left">平台介绍</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="text-align:left"><span style="white-space:nowrap">Gate芝麻开门</span></td>
            <td style="text-align:left"><span style="white-space:nowrap"><a
                        href="https://www.okbtc.cn/gateio?ref=githubio">平台介绍</a></span></td>
            <td style="text-align:left"><a
                    href="https://www.okbtc.cn/gateio?ref=githubio">Gate.io芝麻开门创立于2013年，是全球真实交易量TOP10的加密货币交易平台，向全球数千万用户提供安全可靠、真实透明的数字资产交易服务。</a>
            </td>
        </tr>
        <tr>
            <td style="text-align:left"><span style="white-space:nowrap">Bitget</span></td>
            <td style="text-align:left"><a href="https://www.okbtc.cn/bitget?ref=githubio">注册链接</a></td>
            <td style="text-align:left"><a
                    href="https://www.okbtc.cn/bitget?ref=githubio">Bitget的背后是一群区块链技术的早期接受者，也是区块链未来发展的信仰者，一直致力于提供安全、一站式的交易解决方案，帮助用户更聪明地交易。</a>
            </td>
        </tr>
        <tr>
            <td style="text-align:left"><span style="white-space:nowrap">Bybit</span></td>
            <td style="text-align:left"><a href="https://www.okbtc.cn/bybit?ref=githubio">注册链接</a></td>
            <td style="text-align:left"><a
                    href="https://www.okbtc.cn/bybit?ref=githubio">Bybit通过数字资产与传统金融的结合，引领数字资产的生态发展。提供一流的流动性，致力于打造业内最安全、公平、高效及人性化的交易服务平台。</a>
            </td>
        </tr>
        <tr>
            <td style="text-align:left"><span style="white-space:nowrap">派网</span></td>
            <td style="text-align:left"><a href="https://www.okbtc.cn/pionex?ref=githubio">注册链接</a></td>
            <td style="text-align:left"><a
                    href="https://www.okbtc.cn/pionex?ref=githubio">派网提供多样化的量化交易机器人，用户可依照自身交易需求和策略选择最适合的机器人。 同时派网也提供合约交易与合约网格机器人，给予更方便的合约交易体验。</a>
            </td>
        </tr>
    </tbody>
</table>

        </div>

        
        



        
        


        <footer class="post-footer">
          


          
          <nav class="post-nav">
            
              <a class="prev" href="/post/54743/">
                
                <i class="iconfont">
                  <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

                </i>
                <span class="prev-text nav-default">一文读懂币安 Launchpad 新项目 Arkham，intel to earn 是什么？</span>
                <span class="prev-text nav-mobile">上一篇</span>
              </a>
            
              <a class="next" href="/post/54746/">
                <span class="next-text nav-default">一文介绍社区驱动的漏洞赏金和审计竞赛平台</span>
                <span class="prev-text nav-mobile">下一篇</span>
                
                <i class="iconfont">
                  <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

                </i>
              </a>
          </nav>
        </footer>
      </article>

      
      
        
      


      
      


    </div>

    
    <nav class="toc" id="toc">
    <div class="toc-title">文章目录</div>
    <div class="toc-content custom-scrollbar">
      <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#引言">引言</a></li>
        <li><a href="#nova的优点">Nova的优点</a></li>
        <li><a href="#nova的缺点">Nova的缺点</a></li>
        <li><a href="#nova在零知识证明领域的重要地位">Nova在零知识证明领域的重要地位</a></li>
        <li><a href="#nova的源码解读">Nova的源码解读</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  </nav>


  </div>

      </main>

      <footer id="footer" class="footer">
        <div class="icon-links">
  

<a href="https://www.okbtc.cn/binance?ref=githubio" class="iconfont">
  <img src="/image/logo/binance.png" width="36px" height="36px" alt="binance">
</a>

<a href="https://www.okbtc.cn/okx?ref=githubio" class="iconfont">
  <img src="/image/logo/okx.png" width="36px" height="36px" alt="okx">
</a>

<a href="https://www.okbtc.cn/htx?ref=githubio" class="iconfont">
  <img src="/image/logo/htx.png" width="36px" height="36px" alt="htx">
</a>

<a href="https://www.okbtc.cn/gateio?ref=githubio" class="iconfont">
  <img src="/image/logo/gateio.png" width="36px" height="36px" alt="gateio">
</a>

<a href="https://www.okbtc.cn/bitget?ref=githubio" class="iconfont">
  <img src="/image/logo/bitget.png" width="36px" height="36px" alt="bitget">
</a>

<a href="https://www.okbtc.cn/bybit?ref=githubio" class="iconfont">
  <img src="/image/logo/bybit.png" width="36px" height="36px" alt="bybit">
</a>

<a href="https://www.okbtc.cn/pionex?ref=githubio" class="iconfont">
  <img src="/image/logo/pionex.png" width="36px" height="36px" alt="pionex">
</a>



</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    2023
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        coin
        
      </span></span>

  
  

  
</div>

      </footer>

      <div class="button__back-to-top">
        <a href="#back-to-top">
          <i class="iconfont">
            
            <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

          </i>
        </a>
      </div>
    </div>
    
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.5e8c82c5ae3f71b40f78c4ff8ea351326a65ddf5771f76c10c6fc7d09808332d.js" integrity="sha256-XoyCxa4/cbQPeMT/jqNRMmpl3fV3H3bBDG/H0JgIMy0=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  











<script>
  var remark_config = {
    host: 'https:\/\/remark42.example.com',
    site_id: 'remark',
    components: [
	    'embed',
    ],
  }
  !function(e,n){for(var o=0;o<e.length;o++){var r=n.createElement("script"),c=".js",d=n.head||n.body;"noModule"in r?(r.type="module",c=".mjs"):r.async=!0,r.defer=!0,r.src=remark_config.host+"/web/"+e[o]+c,d.appendChild(r)}}(remark_config.components||["embed"],document);
</script>







  </body>
</html>
